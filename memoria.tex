\documentclass[a4paper, 12pt]{book}
%\usepackage[T1]{fontenc}
\usepackage[a4paper, left=2.5cm, right=2.5cm, top=3cm, bottom=3cm]{geometry}
\usepackage{times}
\usepackage[latin1]{inputenc}
%\usepackage[spanish]{babel} % Comenta esta línea si tu memoria es en inglés
\usepackage[english]{babel} 
\usepackage{url}
%\usepackage[dvipdfm]{graphicx}
\usepackage{graphicx}
\usepackage{float}  %% H para posicionar figuras
\usepackage[nottoc, notlot, notlof, notindex]{tocbibind} %% Opciones de índice
\usepackage{latexsym}  %% Logo LaTeX

\title{Memoria del Proyecto}
\author{Nombre del autor}

\renewcommand{\baselinestretch}{1.5}  %% Interlineado

\begin{document}

\renewcommand{\appendixname}{Apéndice}
\renewcommand{\listfigurename}{Lista de Figuras}
\renewcommand{\contentsname}{Indice General}
\renewcommand{\chaptername}{Cap\'itulo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PORTADA

\begin{titlepage}
\begin{center}
\begin{tabular}[c]{c c}
%\includegraphics[bb=0 0 194 352, scale=0.25]{logo} &
\includegraphics[scale=0.25]{img/logo_vect.png} &
\begin{tabular}[b]{l}
\Huge
\textsf{UNIVERSIDAD} \\
\Huge
\textsf{REY JUAN CARLOS} \\
\end{tabular}
\\
\end{tabular}

\vspace{3cm}

\Large
INGENIERÍA EN TECNOLOGÍAS DE LA TELECOMUNICACIÓN

\vspace{0.4cm}

\large
Curso Académico 2019/2020

\vspace{0.8cm}

Trabajo Fin de Grado

\vspace{2.5cm}

\LARGE
INTERFACES FOR BUILDING SCENES IN VIRTUAL REALITY

\vspace{4cm}

\large
Autor : Javier Jesús Bravo Donaire \\
Tutor : Dr. Jesús María González Barahona
\end{center}
\end{titlepage}

\newpage
\mbox{}
\thispagestyle{empty} % para que no se numere esta pagina


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Para firmar
\clearpage
\pagenumbering{gobble}
\chapter*{}

\vspace{-4cm}
\begin{center}
\LARGE
\textbf{Trabajo Fin de Grado/Máster}

\vspace{1cm}
\large
Interfaces for Building Scenes in Virtual Reality

\vspace{1cm}
\large
\textbf{Autor :} Javier Jesús Bravo Donaire \\
\textbf{Tutor :} Dr. Jesús María González Barahona

\end{center}

\vspace{1cm}
La defensa del presente Proyecto Fin de Carrera se realizó el día \qquad$\;\,$ de \qquad\qquad\qquad\qquad \newline de 20XX, siendo calificada por el siguiente tribunal:


\vspace{0.5cm}
\textbf{Presidente:}

\vspace{1.2cm}
\textbf{Secretario:}

\vspace{1.2cm}
\textbf{Vocal:}


\vspace{1.2cm}
y habiendo obtenido la siguiente calificación:

\vspace{1cm}
\textbf{Calificación:}


\vspace{1cm}
\begin{flushright}
Fuenlabrada, a \qquad$\;\,$ de \qquad\qquad\qquad\qquad de 20XX
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Dedicatoria

\chapter*{}
\pagenumbering{Roman} % para comenzar la numeracion de paginas en numeros romanos
\begin{flushright}
\textit{Dedicado a \\
mi familia / mis amigos / mis compañeros}
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Agradecimientos

\chapter*{Agradecimientos}
%\addcontentsline{toc}{chapter}{Agradecimientos} % si queremos que aparezca en el índice
\markboth{AGRADECIMIENTOS}{AGRADECIMIENTOS} % encabezado 


Página de agradecimientos en proceso.

% Sobre todo, gracias a mi abuela, por todas las veces que veías estudiando y aunque solo llevase diez minutos sentado frente al ordenador, me decías que descansase un poco que estudiar tanto no tiene que ser bueno. 

% A mis amigos, por todas las veces que habeis venido a mi ventana a obligarme a salir de mi habitación, por todas las risas y los enfados, por compartir nuestros lamentos y por esas celebraciones de los éxitos.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen

\chapter*{Resumen}
%\addcontentsline{toc}{chapter}{Resumen} % si queremos que aparezca en el índice
\markboth{RESUMEN}{RESUMEN} % encabezado

Resumen en proceso. Mejor escribirlo al final.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen en inglés

\chapter*{Summary}
%\addcontentsline{toc}{chapter}{Summary} % si queremos que aparezca en el índice
\markboth{SUMMARY}{SUMMARY} % encabezado

Página de resumen escrito en inglés. Al igual que el 
resumen, se escribe lo último.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ÍNDICES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%% Índice de contenidos
\tableofcontents 
%%%% Índice de figuras
\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de figuras} % para que aparezca en el indice de contenidos
\listoffigures % indice de figuras
%%%% Índice de tablas
%\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de tablas} % para que aparezca en el indice de contenidos
%\listoftables % indice de tablas


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCCIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Introducción}
\label{sec:intro} % etiqueta para poder referenciar luego en el texto con ~\ref{sec:intro}
\pagenumbering{arabic} % para empezar la numeración de página con números

En este capítulo se tratan los objetivos tanto principales como específicos, el contexto en el que surgió esta idea, la planificación temporal para la elaboración del mismo, finalizando con una explicación clarificadora sobre la estructura seguida en este escrito.

El fin de este estudio es la elaboración de una interfaz en realidad virtual, disponible desde cualquier navegador. El nacimiento de esta idea surgió con el deseo de introducir a usuarios con un conocimiento bajo sobre los distintos programas de edición de escenas o diseño de modelos 3D, a un entorno intuitivo y de veloz aprendizaje.

El esqueleto del trabajo se compone del framework de creación de experiencias en realidad virtual, A-Frame. A este se le unen otras tecnologías que ayudan a moldear y mejorar este esqueleto, donde se incluyen JavaScript o HTML, entre otras.

\section{Contexto}
\label{sec:seccion}

En los últimos años, el sector tecnológico es uno de los departamentos que más crecimiento ha demostrado, consiguiendo récords de desarrollo en 2018 y 2019. Una de las ramas que se diferencian son la realidad virtual y realidad aumentada, originada en la Segunda Guerra Mundial por la necesidad de crear simuladores de vuelo para instruir a los pilotos. Ya en el año 1960, Morton Heilig\footnote{https://en.wikipedia.org/wiki/Morton\_Heilig} patenta el primer prototipo de visor que reproduce diapositivas en 3D  y sonidos estéreos. 

Durante décadas, los avances en este ámbito se han ido desarrollando positivamente hasta lo que tenemos actualmente:

\begin{itemize}
	\item Distintas marcas desarrollan videojuegos en realidad virtual (Sony, Microsoft).
	\item Múltiples empresas exponen distintos dispositivos para acceder a estos entornos (Oculus, HTC Corporation).
	\item  Simulaciones de vuelo y entrenamiento de pilotos (Fórmula 1, MotoGP).
	\item En medicina, se usan como simuladores de operaciones y al igual que el anterior punto, para el adiestramiento de personal sanitario lo que evita el gasto de material.
	\item Muchos museos usan el sistema de realidad aumentada para mostrar escenas de distintas épocas al espectador.
\end{itemize}

Todas ellas coinciden en su sencillez para un usuario inexperto y en el atractivo de imaginarte en un mundo paralelo donde puedes hacer lo que te plazca. Siguiendo las anteriores aplicaciones, muchas se encuentran en constante desarrollo y son el aliciente del surgimiento de este proyecto.

 El modelado 3D, la creación de escenas o la representación de datos en realidad virtual son tres de las dispares ideas que se encuentran en auge en la actualidad. Aplicaciones de escritorio, como podría ser Blender \footnote{https://www.blender.org/}, adaptadas en un entorno de realidad virtual donde tu puedas modificar el modelo 3D con tus propias manos, o recorrer una ciudad donde cada edificio representa un archivo de tu ordenador e incluso una red de ordenadores donde puedas observar todos los paquetes de comunicación y desplegarlos para ver su información. Todo esto, es solo un pequeño desglose de los ejemplos que me mostró Jesús y llevaron a la elección de esta idea.



\section{Objetivo principal}
\label{sec:estructura}

El objetivo principal de este proyecto se centra en el desarrollo de un entorno de realidad virtual que permita al usuario realizar sus propias escenas mediante la selección y edición de múltiples entidades sin el requisito de tener conocimientos en la rama de edición, de un modo veloz, comprensible y enriquecedor.

\section{Objetivos específicos}
\label{sec:estructura}

Objetivos específicos a los que se irán dando solución según avance el trabajo:

\begin{itemize}
	\item Creación de un panel donde el usuario pueda decidir que objeto crear y poder crear copias infinitas de él.
	\item Añadir una paleta de colores y texturas para cada entidad que permita al usuario decidir el estilo.
	\item Elección del tamaño de los objetos e implementación mediante gestos en la versión con gafas VR.
	\item Adaptación de la versión de escritorio a una versión de realidad aumentada compatible con cualquier dispositivo de visualización.
	\item Dotar de movilidad al usuario tanto para la versión de escritorio como la de realidad virtual.
	\item Asignar dinamismo a la cámara para simular el movimiento y conectarlo con el sonido estéreo con el objetivo de hacer sentir al usuario una experiencia completa.
	\item Modo de edición que represente el esqueleto de las entidades así como los ejes de esta y de la propia escena, para facilitar al usuario la visión y obtener una referencia sobre el ancho y alto real.
	\item La accesibilidad para cualquier usuario al código y a los ejemplos mediante la plataforma GitHub, además de permitir modificarlo y añadir funcionalidades.
\end{itemize}

\section{Planificación temporal}
\label{sec:estructura}

Este proyecto se inici\'o con la apertura del segundo semestre de curso, y se ha ido desarrollando mientras terminaba este y realizaba las pr\'acticas en empresa. Para ello, seguimos el modelo Scrum, en el cual, el proyecto se divide en distintas etapas denominadas "Sprints". Para distinguir estas etapas, manteníamos reuniones (al principio presenciales y más tarde por videoconferencia) en las que se resolvían dudas y se aclaraban los distintos objetivos a conseguir en cada "Sprint". La duración de este han sido un total de 9 meses, en los cuales ha habido temporadas más activas y otras más calmadas debido a exámenes o trabajo, pero en todas ellas el periodo de trabajo era por las tardes después de clase, y sobre todo los fines de semana. En general, todo el proceso de creación 
de este proyecto se puede simplificar en cuatro fases:

\begin{itemize}
	\item Decisión del objetivo. Esta fase consta de las reuniones que llev\'e a cabo mi tutor Jes\'us. En ellas, se hablaba
	de las distintas corrientes de estudio que se podían seguir, 
	decant\'andome al final por la presente.
	
	\item Adaptaci\'on a la tecnolog\'ia. Para adentrarme en las tecnologías mencionadas más adelante en el capítulo \ref{chap:tecnologias}, dicidimos realizar un minijuego que me permitiese
	aprender el funcionamiento de Aframe \ref{sec:aframe} o aprender lenguajes de programación como JavaScript \ref{sec:javascript}.
	
	\item Ejecuci\'on de los objetivos. Las distintas reuniones marcaban el inicio y final de las distintas etapas con las
	que avanzaba el proyecto. Es la fase más amplia de todas ya que es en la que mas documentación es necesaria para avanzar y más tiempo se invierte en la escritura de código, pruebas, etc.
	
	
	\item Redacción de la memoria.
\end{itemize}
 

\section{Estructura de la memoria}
\label{sec:estructura}

Para una correcta lectura del presente proyecto, se aclara la estructura que se sigue a continuaci\'on:

\begin{itemize}
  \item En este primer capítulo se presenta una introducci\'on al
  proyecto, exponiendo sus objetivos y contexto actual, así como la planificación temporal de todo el proyecto.
  
  \item En el capítulo~\ref{chap:tecnologias} se muestran las distintas tecnologías que se enlazan a lo largo del proyecto con algunos ejemplos de uso.
  
  \item A continuación, se presenta el proceso de desarrollo en el capítulo~\ref{chap:disenio}. Además, en él se explica detalladamente el modelo Scrum, los diferentes Sprints y tanto los problemas como objetivos que se van solucionando.
  
  \item El capítulo \ref{chap:resultado} muestra el resultado final desde dos distintas perspectivas, una en la que se expone una guía para el usuario y otra más técnica donde se explica la arquitectura resultante, focalizándose en los componentes que implementa la escena.
  
  \item Las conclusiones quedan recogidas en el capítulo \ref{chap:conclusiones}, donde se analizará todo lo aprendido durante este periodo, los objetivos logrados y los problemas resueltos. 
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBJETIVOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage % empezamos en página impar
\chapter{Tecnolog\'ias} % título del caivopítulo (se muestra)
\label{chap:tecnologias} % identificador del capítulo (no se muestra, es para poder referenciarlo)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ESTADO DEL ARTE %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%

\section{A-Frame} 
\label{sec:aframe}

La gran base de este proyecto es A-Frame\cite{aframe}, un framework cimentado sobre JavaScript que nos ofrece la oportunidad de crear escenas en VR (Virtual Reality o Realidad Virtual) sin la necesidad de instalar ninguna dependencia. Gracias a la unión de HTML, JavaScript, WebGL, WebXR y Three.js (comentados en sus respectivos apartados más adelante), A-Frame lleva la arquitectura ECS (Entity-Component-System o Entidad-Componente-Sistema) a otro nivel. Con esta arquitectura, podemos enlazar componentes a entidades, actualizarlos e incluso eliminarlos. Al obtener el DOM característico de HTML, podemos acceder a las entidades con sentencias simples (Query Selectors).

Se definen así, entidades y componentes. Una entidad es un objeto que tiene sus propiedades como cualquier elemento HTML; en cambio, un componente es un comportamiento especial que se puede asignar a una entidad. La relación entidad-componente será la esencia de aquellos trabajos realizados en A-Frame. 

A-Frame tiene su propia sección de tutorial práctico en el que se introduce al usuario a los distintos elementos y entidades, realizando pequeñas escenas. El código de ejemplo\footnote{https://aframe.io/examples/showcase/helloworld/} que propone la documentación de A-Frame, y que da lugar a la imagen de la Figura \ref{fig:aframe} es el siguiente:
 
\begin{verbatim}
<html>
   <head>
      <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script>
   </head>
   <body>
      <a-scene>
         <a-box position="-1 0.5 -3" rotation="0 45 0"
             color="#4CC3D9"></a-box>
         <a-sphere position="0 1.25 -5" radius="1.25"
             color="#EF2D5E"></a-sphere>
         <a-cylinder position="1 0.75 -3" radius="0.5"
             height="1.5" color="#FFC65D"></a-cylinder>
         <a-plane position="0 0 -4" rotation="-90 0 0" width="4" 
             height="4" color="#7BC8A4"></a-plane>
         <a-sky color="#ECECEC"></a-sky>
      </a-scene>
   </body>
</html>
\end{verbatim}

Como se puede observar, dentro del campo "head" del código, añadiremos todas las dependencias necesarias. En este caso, al ser un ejemplo sencillo, es necesario únicamente el script básico de A-Frame. En el elemento "body" se inserta la escena (que agrupará todos los elementos que posteriormente queramos añadir). En él, se encuentran un total de cinco entidades: un cubo, una esfera, un cilindro, un plano y el cielo, respectivamente. Todas ellas contienen unos atributos únicos que definen su tamaño, color o posición.

Por el momento, no se añade ningún componente en la escena, ya que se usarán en el capítulo \ref{chap:disenio}, pero se añadirían como si de un atributo más se tratase. Estos son creados mediante JavaScript, y se dividen en schema (propiedades del componente) y las funciones init (se ejecuta al inicializar la entidad), update (se ejecuta cuando se modifica la entidad), tick (se ejecuta cada milisegundo), remove (se ejecuta al eliminar la entidad), pause y play. Lo adecuado sería alojarlos en un fichero distinto a este y enlazarlo en el elemento "head" al igual que hemos añadido el script básico de A-Frame.

\begin{figure}
	\centering
	\includegraphics[width=15cm, keepaspectratio]{IMAGENES/aframe}
	\caption{Escena de ejemplo Introducción a Aframe}
	\label{fig:aframe}
\end{figure} 

\section{HTML5}
\label{sec:html}

HTML (HyperText Markup Language)\cite{10.5555/2339435} es el lenguaje de marcado empleado para la creación y estructuración de páginas web. Actualmente se encuentra en su versión HTML5 publicada en 2014 y es en la que se ha desarrollado este proyecto. Algunas de sus novedades frente a su versión HTML4 son:

\begin{itemize}
	\item Se incluyeron nuevas etiquetas al documento: footer, header, section, nav, aside, etc. 
	\item Nuevos componentes de audio y video para la manipulación de elementos multimedia.
	\item Los formularios ahora contienen valores adicionales para la etiqueta input y se incorpora el elemento output.
	\item Nueva interfaz para arrastrar y soltar elementos.
	\item Trabajo off-line descargando todos los contenidos necesarios.
	\item Geolocalización
	\item Ejecución de tareas paralelas (WebWorkers) e interfaz de comunicación entre páginas (WebSockets).
	\item Almacenamiento de datos en el propio navegador gracias a una base de datos (API Storage).
\end{itemize}

Para finalizar, resta detallar el papel del DOM (Document Object Model) en un documento HTML. Consiste de una interfaz que nos proporciona una estructura lógica de todos los elementos implicados en el documento y los organiza en nodos, apodando a esta unión árbol de nodos (Figura \ref{fig:dom}). Esto crea una potente unión entre las entidades mencionadas antes en Aframe y lo que comentaremos a continuación en el apartado de JavaScript, gracias al DOM podremos acceder a ellas y manejarlas a nuestro antojo.

\begin{figure}
	\centering
	\includegraphics[width=15cm, keepaspectratio]{IMAGENES/dom}
	\caption{Estructura en forma de árbol DOM}
	\label{fig:dom}
\end{figure} 

\section{JavaScript}
\label{sec:javascript}

JavaScript\cite{javascript} es un lenguaje de programación interpretado, lo que significa que no necesita de compilación para su ejecución. Su fin consiste en infundir dinamicidad a nuestras aplicaciones web mediante distintas animaciones, manejo de eventos y modificaciones del DOM en general. Como cualquier otro lenguaje de programación puede realizar operaciones, tratamiento de strings, almacenamiento de variables y métodos algorítmicos.

Acceder al DOM gracias a JavaScript se convierte en una tarea sencilla además de potente. El código HTML es estático, pero con JavaScript podemos alterarlo en vivo con distintos eventos. Gracias a sentencias como la siguiente podemos acceder a cualquier elemento, por ejemplo, al título:
\begin{verbatim}

document.getElementsByTagName("h1");

\end{verbatim}

Dicho esto, igual que accedemos al título, podemos acceder a un componente de nuestra escena en A-Frame: cubos, cilindros, el cielo o incluso a la cámara de nuestra escena. Nos aporta infinidad de opciones: crear botones que activen eventos, movimiento a distintas entidades, etc. Junto con todo lo que nos ofrece A-Frame, JavaScript será la base este proyecto.


Habitualmente, el código JavaScript se encuentra en el lado del cliente, pero debido a su gran popularidad se creó una versión con la capacidad de ser ejecutada en el lado del servidor, Node.js.\cite{nodejs} Al estar basado en JavaScript, mantiene las ventajas de este, sigue siendo software libre y además, es asíncrono. Su función principal es el manejo de solicitudes de entrada y la salida de respuesta, llegando incluso a poder realizar una solicitud HTTP. 

\section{WebGL}
\label{sec:webgl}

WebGL\cite{Cozzi15} define una API (Application Programming Interfaces o Interfaz de Programación de Aplicaciones) basada en OpenGL\footnote{https://www.opengl.org//documentation/} cuyo fin es la representación tanto en 3D como en 2D de elementos gráficos. Como se ejecuta en el elemento "canvas" de HTML, se integra a la perfección con la interfaz del DOM. Su creación nació en 2006 con el primer prototipo de Canvas 3D presentado por Vladimir Vukicevic\footnote{https://en.wikipedia.org/wiki/Vladimir\_Vuki\%C4\%87evi\%C4\%87}, y no fue hasta principios de 2009 que el consorcio Kronos Group consolidó el WebGL Working Group junto con Google, Mozilla, Apple y Opera, entre otros. Finalmente, en 2011 fue lanzada la primera versión con sus correspondientes especificaciones.

Al estar asentado en OpenGL, su código está escrito en JavaScript y "shading language". Shading language o lenguaje de sombreado, es un lenguaje de programación basado en la creación de efectos de sombreado, así como superficies, volúmenes, etc. Usa unos tipos de datos más específicos que otros lenguajes, como pueden ser: vectores, matrices o colores. Para el caso de OpenGL, recibe el nombre de GLSL o "glslang".


\section{Three.js}
\label{sec:three}

Three.js\cite{three} es una biblioteca escrita en JavaScript que se ayuda de WebGL para pintar en 3D. Three se encarga de tareas más específicas que las que aporta WebGL, lo que conlleva a escribir un poco más de código. Estas tareas son la inyección en nuestro proyecto de texturas, iluminación, sombras, etc.

Actualmente se encuentra en constante desarrollo, y al estar alojada en GitHub\footnote{https://github.com/mrdoob/three.js/}, se pueden crear funcionalidades nuevas siguiendo determinadas reglas comentadas en el apartado correspondiente a GitHub.

\section{WebXR}
\label{sec:webxr}

WebXR \cite{baruah2021ar} es un grupo de estándares que apoyan a la creación de escenas 3D tanto en realidad virtual como en realidad aumentada, que junto con Aframe, WebGL y Three.js permitirán el correcto funcionamiento de la escena y la apropiada ejecución en un dispositivo XR. Es la sucesora de WebVR, la cuál se ha dado como desactualizada este mismo año (2020), y añade la compatibilidad con realidad aumentada, de ahí que el nombre cambie de WebVR a WebXR. La API de WebXR aporta unas funcionalidades extra de las cuales, el usuario puede no necesitar hacerse cargo:

\begin{itemize}
	\item Duplicar la salida 3D (en el dispositivo) a una 2D en el caso que fuese necesaria, por ejemplo, para la depuración de una aplicación.
	\item Crear los vectores que representan los movimientos que transmiten los controles de entrada (mandos).
	\item Renderizar la escena que se envía al dispositivo para que tenga el ratio de frames por segundo adecuado para su correcto funcionamiento.
	\item Averiguar si el dispositivo de salida es compatible con realidad aumentada o con realidad virtual.
\end{itemize}

Los dispositivos XR serán entonces, aquellos que pueden presentar imágenes al usuario e incorporen un sistema de rastreo de movimiento y orientación, permitiendo la inmersión completa de este.

\section{GitHub}
\label{sec:github}

GitHub\cite{munaiah2017curating} es una de las mayores plataformas de almacenamiento de software y proyectos basado en el sistema de control de versiones Git\cite{git}, creado por Linus Torvalds\footnote{https://es.wikipedia.org/wiki/Linus\_Torvalds} en el año 2005.

El propósito de Git es la eficiencia de producción y el mantenimiento de un registro de los cambios que se producen, con el fin de coordinar el trabajo compartido. Para lograr esto, se aclaran unas normas a seguir que reciben el nombre de Flujo de Trabajo.

Git sigue una estructura de árbol, en la que cada rama representa un flujo de trabajo. La rama principal recibe el nombre de "master", esta rama contiene la versión funcional del proyecto que se esté llevando a cabo, es la rama de producción. Para crear esta rama necesitamos establecer un repositorio en el que poder añadir nuestros archivos y añadirlos. Git tiene una serie de comandos para realizar todas estas acciones, por ejemplo, para crear el repositorio usamos \textit{git init}, y para añadir nuestros archivos (consiguiendo así protegerlos) \textit{git commit} seguido de \textit{git push}.

Para prevenir que se trabaje todo sobre la versión de producción, Git aporta un comando para crear ramas adicionales en las que distintos grupos de trabajo pueden trabajar para evitar modificar los mismos archivos y eliminar sus propios avances, \textit{git branch}. Una vez terminada la funcionalidad en la que se trabaja en una rama aparte, se debe enlazar con la rama maestra, para ello empleamos el comando \textit{git merge}. Se forma así una estructura de árbol como la que podemos observar en la Figura \ref{fig:git}, en la que cada nodo corresponde con una representación de nuestros archivos comprometidos, lo que se llama "log". Gracias a esto, podemos volver a antiguos nodos del árbol para recuperar versiones anteriores, eliminar otros, etc.

Tomando como base Git, GitHub nos permite visualizar en su plataforma web el flujo de trabajo conseguido. La principal diferencia entre ambos consiste en que GitHub nos aporta una interfaz gráfica de nuestro árbol, mientras que Git solo funciona a través de comandos en una terminal. Asimismo, GitHub añade más herramientas que nos aportan claridad y orden al proyecto:

\begin{itemize}
	\item Creación de perfiles para cada usuario donde se muestran los repositorios en los que trabaja (tanto propios como conjuntos), junto con estadísticas de trabajo: lenguajes de programación más usados, historial de producción, etc.
	\item Página de "wiki" para cada repositorio en la que se puede comentar cada apartado de este para que los lectores puedan apoyarse. 
	\item Una sección llamada "issues" donde los usuarios pueden dejar un mensaje comentando cualquier fallo que hayan encontrado en nuestro trabajo.
	\item La casilla "projects" permite crear tareas que se pueden asignar a distintos grupos de trabajo para tener un control de las funcionalidades que se están creando, así como creación de columnas para ordenar estas tareas según si se encuentran finalizadas, en proceso o por iniciar.
	\item Capacidad de copiar un repositorio ajeno para trabajar sobre él. Esto es lo que se conoce como "fork", nos permite editar los archivos y en el caso de mejorar alguna funcionalidad, podemos solicitar al autor una unión (merge) con lo que se denomina "pull request". 
\end{itemize}

Todas estas cualidades mostradas, han sido las responsables para decidirme a alojar y proteger mi proyecto en GitHub\footnote{https://github.com/JavierBravoDonaire/A-frame}.

\begin{figure}
	\centering
	\includegraphics[width=15cm, keepaspectratio]{IMAGENES/git}
	\caption{Estructura de ramas Git}
	\label{fig:git}
\end{figure}

\section{Atom}
\label{sec:atom}

Atom\cite{atom} ha sido el editor de textos elegidos para aposentar todo el código necesario para el funcionamiento de esta idea. Gracias a tratarse de un programa de código abierto, podemos encontrar infinidad de bibliotecas para modificarlo a nuestro gusto. Entre sus ventajas se encuentran:

\begin{itemize}
	\item Autocompletado de sentencias. Si existe un paquete relacionado con el lenguaje de programación que se va a usar, atom completará las sentencias añadiendo los paréntesis, corchetes, tabuladores o elemento que se necesite.
	\item Reglas de estilo. Semejante al anterior punto, dotará de distintos estilos al código, las variables serán de un color, los nombres de función de otro, etc.
	\item Sincronización con repositorios. Una de las herramientas más potentes es la capacidad de sincronizar con GitHub tu proyecto. Esto permite a atom mostrarte los archivos que han sido modificados, los que no se han comprometido, los nuevos o los que siguen intactos.
	\item Edición múltiple. Tolera varias flujos de escritura a la vez, por ejemplo si necesitamos añadir a varios elementos el mismo atributo, escribiéndolo una vez, se escribiría en todos ellos sin necesidad de copiar y pegar.
\end{itemize}

\section{LaTeX}
\label{sec:latex}

LaTeX\cite{lamport1994latex} trata de un procesador de textos de software libre típicamente utilizado para textos técnico-científicos. Su objetivo principal es separar las reglas de estilo del contenido. La diferencia más importante con respecto a otros editores de textos es su estructura basada en instrucciones. Entre sus ventajas se encuentran la capacidad de establecer órdenes al inicio de nuestro texto que afectarán a este, o la despreocupación a la hora de situar figuras y tablas, ya que como he comentado antes, él se encarga del estilo, nosotros del contenido.

Al tratarse de un software libre su uso es completamente gratuito (además, de que se mantiene siempre en desarrollo) y se encuentra disponible para múltiples sistemas operativos.\footnote{\url{https://www.latex-project.org}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DISEÑO E IMPLEMENTACIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Diseño e implementación}
\label{chap:disenio}

Para poder explicar todo el proceso de diseño del proyecto, tengo que comenzar hablando de Scrum\cite{scrum}. Scrum es una metodología de trabajo desarrollada en el año 1993 por Jeff Sutherland\footnote{https://www.scrumguides.org/jeff.html} y Ken Schwaber\footnote{https://www.scrumguides.org/ken.html}, y finalmente formalizada en el año 1995. El objetivo de esta es conseguir un desarrollo ágil y productivo con la mejor organización posible para llegar a un producto completo. En ella, se define que el trabajo realizado debe organizarse en distintos espacios de tiempo denominados iteraciones o "Sprints" en los que se definen una serie de objetivos, y no se da paso al siguiente "Sprint" hasta que se solucionan los problemas y se consigue todo lo planeado en el anterior.

El equipo que emplee esta metodología debería dividirse en tres partes: el Scrum Master, el Equipo de Trabajo y el Cliente. En este caso, el papel de Scrum Master lo lleva a cabo el profesor, Jesús, (aunque también podría adquirir el papel de Cliente) y el papel del Equipo de Trabajo lo representa el alumno, en este caso, yo. El objetivo del Scrum Master consiste en asegurar el entendimiento de las reglas y prácticas llevadas acabo. Además, mantiene una estrecha relación con el Cliente haciendo de intermediario entre este y el Equipo de Trabajo, consiguiendo y aclarando los objetivos propuestos y aportando técnicas para una efectiva producción. Por otro lado, el Equipo de Trabajo esta formado por los profesionales que se encargar del desarrollo y resolución de problemas que propone el Cliente. Son los encargados de la consecución de los objetivos para poner fin a los distintos "Sprints".

Para este caso en particular, cada reunión entre Jesús (Scrum Master/Cliente) y yo (Equipo de Desarrollo), marcarán el inicio y final de cada "Sprint". Inicialmente, una reunión marcará los objetivos a conseguir en ese "Sprint", durante unas semanas se trabaja en ello y finalmente se prepara una nueva reunión. En esta nueva reunión, se hablan de los problemas que han surgido y lo conseguido. Si se han logrado con éxito cada una de las metas propuestas, esta reunión será la que dará fin a ese "Sprint" e iniciará el siguiente. Normalmente, en cada "Sprint" se crea una versión funcional que implementa lo conseguido y da paso como versión inicial al siguiente. En caso contrario, se tratan las dudas y problemas surgidos intentando llegar a una solución. Se trabaja en esto durante un periodo y se vuelve a tener la reunión hasta conseguir la versión funcional y dar paso al siguiente "Sprint" hasta llegar a la versión final del producto, como podemos observar en la Figura \ref{fig:scrum}.

\begin{figure}
  \centering
  \includegraphics[width=15cm, keepaspectratio]{IMAGENES/scrum}
  \caption{Estructura de la metodología Scrum}
  \label{fig:scrum}
\end{figure}

Por último, algunas de las ventajas del uso de Scrum son las siguientes:
\begin{itemize}
	\item Los "Sprints" se realizan de manera mensual (o de varias semanas), lo que permite un avance rápido y marcado del trabajo, además de conseguir gradualmente resultados antes del producto final.
	\item Existe una flexibilidad entre el cliente y el equipo de desarrollo que permite el intercambio de ideas o soluciones de problemas, debido a las reuniones mensuales.
	\item Rígida definición de plazos y tareas.
	\item Reducción de la complejidad de un proyecto complejo gracias a su desglose en etapas.
	\item Mayor satisfacción moral del equipo y por consiguiente, mejora del ambiente de trabajo.
\end{itemize}


\section{Sprint 1} 
\label{sec:sprint1}

Esta iteración comienza con la primera reunión que mantuvimos Jesús y yo. En ella se acordó que para empezar debía iniciarme en Aframe junto con JavaScript (hasta el momento desconocido para mí) y HTML entre otros, por lo que la idea sería crear un minijuego básico que uniese todas las tecnologías.

\subsection{Objetivo}

El objetivo de esta fase es aprender a usar Aframe, en esto se incluye: aprender que son las entidades, crear entidades, crear eventos, crear componentes, dinámicas y físicas, etc. Como JavaScript es desconocido para mí, otro gran objetivo es ir aprendiendo a la vez que lo enlazo con Aframe. El fin del minijuego es hacer un pequeño recorrido en el tengas que realizar distintas acciones para llegar a la meta.

\subsection{Desarrollo}
La idea es crear un recorrido con distintos obstáculos que implementen distintas acciones y eventos para adecuarme a ellos. El recorrido es el que sigue a continuación: 
\begin{enumerate}
	\item Apareces en un estrecho pasillo con una puerta delante, la cual debes abrir llamando al timbre y evitando los dos obstáculos que tratarán de tirarte como se puede observar en la Figura \ref{fig:mini_inicio}.
	\begin{figure}
		\centering
		\includegraphics[width=15cm, keepaspectratio]{IMAGENES/mini_inicio}
		\caption{Punto de partida Minijuego}
		\label{fig:mini_inicio}
	\end{figure}
	
	\item Una vez abiertas las puertas, el pasillo continúa  dejando paso a dos plataformas que te permiten llegar al segundo piso (Figura \ref{fig:mini_plataforma}). Para ello, debes subirte en una de las dos plataformas en el momento correcto. 
	\begin{figure}
		\centering
		\includegraphics[width=15cm, keepaspectratio]{IMAGENES/mini_plataforma}
		\caption{Plataformas para subir de nivel}
		\label{fig:mini_plataforma}
	\end{figure}
	
	\item Ya subidos en la plataforma giraremos 180 grados para encontrarnos un nuevo obstáculo en movimiento, la piedra gigante (Figura \ref{fig:mini_bloque}). Pero para llegar a ella primero debemos empujar las dos piedras que nos cortan el camino, haciendo así que caigan al vacío.
	\begin{figure}
		\centering
		\includegraphics[width=15cm, keepaspectratio]{IMAGENES/mini_bloque}
		\caption{Piedras que bloquean el camino y bloque gigante}
		\label{fig:mini_bloque}
	\end{figure}
	
	\item Para conseguir cruzar debemos parar el bloque gigante a nuestros pies, lo que nos dejará ver el siguiente y último reto,
	las baldosas móviles (Figura \ref{fig:mini_baldosas}). Cruzando con cuidado llegaremos a la última plataforma gigante.
	\begin{figure}
		\centering
		\includegraphics[width=15cm, keepaspectratio]{IMAGENES/mini_baldosas}
		\caption{Obstáculo de baldosas con movimiento}
		\label{fig:mini_baldosas}
	\end{figure}
	
	\item En el centro de esta plataforma nos espera un botón que invoca un evento de felicitación junto con las palabras de fin del juego.
\end{enumerate}

Son muchos obstáculos pero esto permite que utilice el mayor número de entidades y cree los eventos necesarios. Por último, si caes en cualquier momento, volverás al inicio para además añadirle un nivel de dificultad, al fin y al cabo, es un juego.

Para crear este pequeño juego se comienza con un archivo HTML en el que se importan los scripts necesarios de Aframe para poder comenzar a crear entidades, estos son algunos de ellos:
\begin{verbatim}
	<script src="../../assets/js/aframe.min.js"></script>
	<script src="../../assets/js/aframe-physics-system.min.js"></script>
\end{verbatim}
Gracias a esto podemos empezar a crear nuestras entidades. Las entidades son los distintos objetos que podemos crear como pueden ser un plano, un cilindro o un cubo, entre otros. Para este caso, el pasillo será un plano, las puertas serán cubos y las plataformas cilindros. Todas las entidades tienen propiedades que pueden ser modificadas dinámicamente, mediante eventos por ejemplo. Modificando las propiedades rotación, ancho y largo del plano, podemos crear nuestro pasillo:

\begin{verbatim}
	<a-plane position="0 0 0" rotation="-90 0 0" width="3.25" height="20"
	src="#floor" repeat="1 5" static-body></a-plane>
\end{verbatim}

En el apartado "src" podemos asignar una textura a nuestras entidades, mientras que con "repeat" podemos hacer que se repita la textura para que no pierda calidad, o crear incluso un pasillo de baldosas como el visto anteriormente. Siguiendo estas reglas, podemos crear todas las entidades necesarias para nuestra escena. Ahora sólo queda añadir las dinámicas y eventos a estas, al igual que animaciones. 

Aframe no nos aporta figuras más complejas que cubos, cilindros, etc. Por eso, podemos crearlos nosotros con distintas aplicaciones de edición 3D en formato gltf\footnote{https://es.wikipedia.org/wiki/GlTF} e importarlas a nuestra escena. Podemos usar distintas páginas web con diseños completamente gratuitos de modelos 3D para nuestras aplicaciones, una de ellas es Sketchfab \footnote{https://sketchfab.com/feed}. Por ejemplo, los diseños del obstáculo de las hachas los encontré en esta página.

Para hablar de los eventos, tomaré como ejemplo el botón para abrir las puertas. El botón es una caja que tiene como propiedad el componente "clickable". Esto permite acceder a el gracias a JavaScript y que cada vez que se posicione el ratón encima de la entidad y se haga click en él, se dispare un nuevo evento. Al capturar ese evento, podemos modificar propiedades de una entidad en tiempo real. El siguiente código muestra un ejemplo de ello:

\begin{verbatim}
	buttonEl.addEventListener('mouseenter', function() {
	   buttonEl.setAttribute('color', "gray");
	   buttonEl.setAttribute('scale', "0.22 0.22 0.22");
	});
\end{verbatim}

Así podemos hacer que al pulsar el timbre (que es un cubo), la rotación de las puertas cambien 90 grados (lo que hace que la puerta se abra). Los mismos principios se siguen para hacer que el bloque gigante se pare para que podamos pasar o el botón que activa la escena final del juego.

El movimiento de las hachas, las plataformas que nos suben de piso o las baldosas que nos impiden cruzar es a lo que se llama animación. Una animación nos permite establecer un patrón de movimiento en una entidad (las entidades son estáticas). La animación es otra propiedad de la entidad como puede ser el ancho, se declara como sigue:
\begin{verbatim}
<a-cylinder class="platform" position="1.5 22 -12" 
animation="property: position; dur: 10000; to: 1.5 -1 -12;
dir: alternate; loop: true" static-body></a-cylinder>
\end{verbatim}

En este trozo de código declaramos la duración de la animación, la posición final donde acaba, si es infinita y si se alterna o no. Este es el código que usan las plataformas para subir, empiezan en una posición, acaban en otra y gracias al atributo "alternate", cuando llegan a la posición final vuelven a la inicial como si de un ascensor se tratara.

Para completar este apartado, resta explicar los usos de los componentes. Un componente es un comportamiento que se asocia a una entidad, por ejemplo el antes mencionado "clickable". Para conseguir la función de reaparición del jugador cada vez que caía del escenario, creé el siguiente componente, en el que se detallan estas condiciones:

\begin{verbatim}
AFRAME.registerComponent('restart', {
// ...
   schema: {
      checkpoint: {type: 'string', default: '0 0 9'},
   },

   tick: function () {
      var audio = document.querySelector('#deathsound');
      var data = this.data;

      if(this.el.getAttribute('position').y < -6){
         this.el.setAttribute('position', data.checkpoint);
         audio.play();
      }
    }
});
\end{verbatim}
En este componente aparece la función "tick", la cual se ejecuta cada milisegundo, comprobando si la posición "y" del jugador es menor (para así saber si ha caído) y haciendo que reaparezca en el inicio. Los componentes son herramientas muy potentes, ya que nos permiten crear funciones complejas como esta y simplifica el código. Para asociar un componente a una entidad debemos incluirlo como, ya hemos visto anteriormente, un atributo cualquiera.

\subsection{Funcionalidades añadidas}
Siguiendo todo lo comentado en el anterior apartado, se agregaron unas funcionalidades no tan básicas para complementar el juego.
\begin{itemize}
	\item Dinámicas. Como se puede observar en las figuras anteriores, el jugador tiene alrededor un cilindro verde. Este cilindro es el que marca la caja de colisión del jugador para que no pueda atravesar las puertas, pueda empujar las piedras y pueda subirse en las plataformas sin caer. Estas dinámicas vienen dadas en el script kinema.js\footnote{https://www.npmjs.com/package/kinema/v/0.0.1}.
	\item Aprovechando el componente "restart" para cuando el jugador caiga, añadí una funcionalidad de punto de guardado. Cuando llegas al piso de arriba se puede observar un boton de "checkpoint" (Figura \ref{fig:mini_bloque}) para no tener que iniciar desde el principio y reaparecer arriba.
	\item Efectos de sonido. Se incorporaron efectos de sonido en el evento final del juego, al abrir puertas o al detener el bloque.
	\item Gafas VR. Por último, se adecuó el minijuego para poder jugarlo con las gafas de realidad virtual. Para ello, se necesitaron nuevos componentes que representasen nuestras manos en la escena y pudiesemos usarlas como si fuesen el ratón. Este componente podemos encontrarlo su propia página de GitHub\footnote{https://github.com/wmurphyrd/aframe-super-hands-component}.
\end{itemize}

\subsection{Resultado}
Como iniciación a las nuevas tecnologías, el resultado fue notablemente bueno. Pude practicar con muchas de las posibilidades que me ofrecía Aframe mientras aprendía JavaScript. Además, tuve mi primer contacto con las gafas de realidad virtual en las que pude depurar el final de mi juego (Figura \ref{fig:mini_fin}). El minijuego se encuentra alojado en la página de GitHub del proyecto y puede ser jugado\footnote{https://javierbravodonaire.github.io/A-frame/Sprint\%201/my-examples/minigame.html}. El código JavaScript\footnote{https://github.com/JavierBravoDonaire/A-frame/blob/master/Sprint\%201/my-examples/minijuego.js} se encuentra a su vez alojado en la carpeta correspondiente a este "Sprint" junto a su HTML\footnote{https://github.com/JavierBravoDonaire/A-frame/blob/master/Sprint\%201/my-examples/minigame.html}. Para terminar, se mantuvo una reunión en la que se comentó lo aprendido gracias a este "Sprint" y dió comienzo al siguiente apartado.

\begin{figure}
	\centering
	\includegraphics[width=15cm, keepaspectratio]{IMAGENES/mini_fin}
	\caption{Escena victoria}
	\label{fig:mini_fin}
\end{figure}


\section{Sprint 2} 
\label{sec:sprint2}

Debido al avance y conocimientos obtenidos gracias a la anterior iteración, en esta se expusieron las bases del proyecto. Como consecuencia a todos los objetivos que se verán a continuación, se llevaron a cabo un par más de reuniones para conseguir un asentamiento adecuado del trabajo.

\subsection{Objetivo}

El objetivo final de esta fase consiste en establecer un panel de selección que nos deje elegir entre una mesa de entidades u otro panel de entidades. Al lado de ese panel tendremos un podio, en el cual aparecerán entidades que elijamos en el panel o en la mesa infinitamente. Para ello, haré uso de distintos eventos para generarlas y definiré los elementos básicos de la escena en el archivo HTML.

\subsection{Desarrollo}

Al tratarse de los cimientos del programa, se trabajarán las fases una encima de otra (esto significa, en los mismo archivos). Con el propósito de explicar todo el proceso ocurrido en esta iteración se dividirá en x etapas.

\subsubsection{Etapa 1:}

En esta primera fase se trabajó en una escena que ofreciese un panel con distintos botones, que permitiese la elección de diferentes figuras. Para empezar, se debe crear un entorno en el que el usuario se sienta cómodo, y para ello, se crea un plano en horizontal (el cual estará dotado de una rotación de 90 grados) que simule el suelo y se dota a la escena del elemento "sky" (con una textura que se asemeje al cielo) para que parezca que nos encontramos en un plano real. Una vez tenemos el suelo, ya podemos empezar a situar nuestros elementos.

El panel será entonces un plano, de un tamaño razonable, en el cual se colocarán los botones. Para crear los botones, usaremos un cubo al que le modificaremos su propiedad "depth" (profundidad), para dar la sensación de apretar un botón (Figura \ref{fig:Rooster_TFG}). Cada botón tendrá un texto donde se indica que objeto crea. Este texto se añade creando una entidad "a-text" y enlazándola con el botón.

\begin{figure}[H]
	\centering
	\includegraphics[width=10cm, keepaspectratio]{IMAGENES/Rooster_TFG}
	\caption{Panel con botones para generar entidades}
	\label{fig:Rooster_TFG}
\end{figure}

Para crear las entidades necesitamos hacer uso de eventos mediante JavaScript. Le asignaremos a cada botón un "id" distinto para poder acceder a todos ellos como un elemento cualquiera del DOM, y le añadiremos un evento. Este evento se encargará de detectar si en algún momento se ha pulsado sobre un botón, y cuando esto suceda se creará la entidad a la que se refiere el mismo. Para conseguir capturar este evento, debemos dotar a los botones con el atributo "clickable" definido en el script de A-Frame, el cual le da la cualidad de ser pulsado. Si pulsamos todos los botones nos encontraremos una escena como la que se puede observar en la Figura \ref{fig:RoosterEntities_TFG}.

Como queremos mantener el código lo más limpio posible y evitar la repetición de lineas, se crea un apartado en el HTML llamado "assets" donde podemos crear los llamados "mixin". Un mixin es una especie de entidad genérica en la que declaras su material, tamaño, etc, y a partir de ella puedes crear clones. Un ejemplo para comprobar su utilidad podría ser el siguiente: imaginemos que queremos crear tres cubos pulsando un botón, entonces desde el JavaScript debemos manejar el evento y crear desde el mismo la entidad, sentencia a sentencia, declarando el color, el tamaño y la posición. Con el mixin ya hemos declarado todos estos atributos, por lo que solo necesitaríamos declarar que es un "mixin-cubo" y nos ahorraríamos todas las sentencias de sus propiedades en el JavaScript. Un mixin para un cubo es como el siguiente:

\begin{verbatim}
    <a-mixin id="box" hoverable grabbable stretchable draggable
    geometry="primitive: box; width: 0.5; height: 0.5; depth: 0.5"
    droppable</a-mixin>
\end{verbatim} 


\begin{figure}
	\centering
	\includegraphics[width=12cm, keepaspectratio]{IMAGENES/RoosterEntities_TFG}
	\caption{Entidades generadas con el panel}
	\label{fig:RoosterEntities_TFG}
\end{figure}

\subsubsection{Etapa 2:}

Fue entonces cuando surgió la idea de que sería más adecuado tener dos modos de creación de objetos. Una de ellas sería el panel que ya tenemos, y la otra sería una mesa de entidades, donde las encontrases todas y pudieses agarrarlas, dotando al programa de una visión más intuitiva.

Para ello, me apoyé nuevamente en los modelos 3D ofrecidos por la página Sketchfab\footnote{https://sketchfab.com}. Ya que A-Frame no ofrece objetos tan complejos como puede ser una mesa, buscar un diseño agradable y gratuito era la mejor opción. Para agregar a la escena estos objetos, debemos declararlos en el mismo apartado que declaramos los mixin, en "assets". Debemos prestar atención a la escala de los modelos 3D, ya que no están diseñados para añadirlos a las escenas directamente y lo más probable es que sean gigantescos.

Una vez tenemos la mesa en nuestra escena, es hora de colocar las entidades encima de ella para poder elegir. Con el objetivo de dotar a la escena de más movilidad, se añadieron animaciones y se modificó la opacidad y transparencia del color para dar la sensación de unos hologramas que flotan por encima de la mesa (Figura \ref{fig:Holo_TGF}).
	
\begin{figure}
	\centering
	\includegraphics[width=10cm, keepaspectratio]{IMAGENES/Holo_TGF}
	\caption{Mesa con entidades holográficas}
	\label{fig:Holo_TGF}
\end{figure}

Por último, se debe añadir la funcionalidad de elección para crear un clon de la entidad con la que podamos trabajar (igual que creábamos los objetos al pulsar el botón). En este caso, era el propio holograma el cual, al pulsar sobre él, nos creaba una copia. La copia se generaba delante del usuario y para lograr esto se tomaba como punto de referencia la posición de la cámara, consiguiendo así que la entidad se generase en frente, dando igual desde que posición la cogieses.

\subsubsection{Etapa 3:}

Como ya tenemos nuestros modos de selección, ahora debemos añadir una funcionalidad que implique cambios en las entidades. La idea principal es crear una paleta de colores y texturas que nos permita en cualquier momento cambiar el estilo de esta. Esta aparecerá cuando pulsemos sobre la entidad, por lo que debemos tener cuidado con el evento que lance esta acción. 

La paleta nos aporta un buen ejemplo de lo que son los nodos. La entidad tendrá un nodo hijo que será el plano que representa la paleta, que a su vez tendrá x hijos que serán los botones que representan los diferentes colores y texturas (Figura \ref{fig:paleta}). Es aquí, cuando me enfrente a un gran problema, los eventos escalan hacia las entidades padre, por lo que se debe detener el evento para que no afecte y genere comportamientos inadecuados. En esta ocasión, el evento de cambiar el color, afectaba tanto a la entidad como al plano que representa la paleta, por lo que se debía controlar.

La paleta se compone así de un total de ocho opciones dividas en dos filas. La primera fila se corresponde con cuatro colores distintos, y la segunda contiene tres texturas diferentes y un último botón que devuelve a la entidad el color original con el que fue creada.

\begin{figure}
	\centering
	\includegraphics[width=10cm, keepaspectratio]{IMAGENES/paleta}
	\caption{Paleta de colores perteneciente a una entidad}
	\label{fig:paleta}
\end{figure}

\subsubsection{Etapa 4:}

Terminadas todas las funcionalidades propuestas, solo restaba unificar los dos modos de selección. Para ello, se optó por un panel con dos opciones a elegir: la mesa o el panel de entidades. Esta tarea es fácil, ya que hemos hecho un panel con botones anteriormente, solo debemos controlar los eventos para generar la mesa (ya que ahora no se encuentra nada más iniciar la escena) y el otro panel, pero esto nos conduce al siguiente dilema, los dos modos tienen una forma diferente de generar las entidades.

Esto da lugar a la idea de crear un podio, en el cual, aparecerán las entidades según las seleccionemos tanto en la mesa como en el panel (con el panel aparecían en un lugar predeterminado declarado en el código para cada entidad, y con la mesa aparecían delante de nosotros). Se crearán así todas las entidades que necesitemos y por último, las agregaremos el atributo "grabbable", el cual dotará a estas de movilidad para poder arrastrarlas por toda la escena. Quedará entonces una escena como la que podemos ver en la Figura \ref{fig:sprint2}, donde observamos el podio con una entidad sobre él, una entidad aparte con su paleta de edición, la mesa de entidades, el panel donde elegimos el modo de selección y el panel de elección de entidad.

\begin{figure}
	\centering
	\includegraphics[width=13cm, keepaspectratio]{IMAGENES/sprint2}
	\caption{Versión funcional conseguida al final del Sprint 2}
	\label{fig:sprint2}
\end{figure}

\subsection{Resultado}

Gracias a esta iteración hemos sentado las bases y varias funcionalidades que darán paso a las siguientes etapas. Todos los eventos y funciones empleados se recogen en el código JavaScript\footnote{https://github.com/JavierBravoDonaire/A-frame/blob/master/Sprint\%202/improve.js} alojado en el repositorio de GitHub, así como el código HTML\footnote{https://github.com/JavierBravoDonaire/A-frame/blob/master/Sprint\%202/improve.html} donde se definen los elementos iniciales de la escena. Como en el anterior apartado de resultado y en los siguientes, se adjunta la dirección para probar esta versión en el navegador\footnote{https://javierbravodonaire.github.io/A-frame/Sprint\%202/improve.html}.

\section{Sprint 3} 
\label{sec:sprint3}

Una vez establecidas las bases de la escena, se deben implementar nuevas funcionalidades que aporten dinamismo y utilidad. La reunión que finalizó la anterior iteración, fue la misma que generó los objetivos de esta. Como ya me había adecuado al estilo de A-Frame y al lenguaje JavaScript, era hora de añadir opciones más complejas.

\subsection{Objetivo}

Hasta ahora, podemos generar entidades infinitamente encima del podio y cada una de ellas tiene su propia paleta de colores, pero esta opción no es la más intuitiva. Por ello, la mejor opción es añadir en el propio panel donde creamos las entidades, otra paleta de colores y texturas. Pero existe un problema, la entidad no se crea hasta que no la eliges, y una vez seleccionada ya se ha creado con su color por defecto, por eso se creará la principal funcionalidad propuesta en esta iteración, el podio con entidad dinámica. 

El podio con entidad dinámica trata del mismo podio, pero en este caso ya existe una figura flotando por encima de este, y pulsando sobre los distintos botones de color, textura o incluso entidad, es la propia figura la que cambia. Entonces, existirá una sola figura flotante que cambiará según nuestras indicaciones, y cuando la arrastremos fuera del podio se creará una copia para poder seguir editando entidades infinitamente.

Por último, se añadirá una función para, al igual que elegimos el estilo de las figuras, podamos elegir su tamaño.

\subsection{Desarrollo}

Como el fundamento de esta iteración es la entidad cambiante que se encuentra encima del podio, lo primero es crearla. Para ello, debemos entender como funcionan las relaciones padre-hijo. El podio es una entidad hija de la escena y a su la vez, la entidad cambiante será una hija del podio. Con esto, conseguiremos realizar correctamente la generación de una nueva entidad cuando saquemos la que se encuentra en el podio. A continuación, se explica paso a paso como se realiza esta funcionalidad, para que quede de forma clara:

\begin{enumerate}
	\item Como en la iteración anterior ya importamos el modelo del podio, no necesitamos crearlo de nuevo. Se crea un entidad aleatoria (en mi caso elegí un cubo), que será la que aparezca al inicio de la escena y sobre la que editaremos.
	\item Debemos crear esa entidad como hija del podio, de forma que la posición, el tamaño y la función de arrastras se vean afectadas por este. Una entidad que sea hija de otra dependerá en sus atributos de su nodo padre, entonces, si queremos que la entidad este flotando, solo se necesitará modificar la posición en el eje "y" (el padre es la posición de referencia).
	\item Siguiendo esos pasos, ya tenemos el podio y la entidad colocada perfectamente. Como vamos a necesitar acceder a los atributos de la entidad para realizarle cambios, debemos añadirle un "id" único, el cual nos permitirá hacerle referencia desde nuestro código JavaScript (donde se encuentra toda la funcionalidad).
	\item Añadimos al panel distintos botones (a los que ya había), con texturas y colores diferentes. Ahora, debemos modificar el código anterior, ya que no vamos a crear entidades directamente, vamos a modificar una existente. Se divide así el código en dos partes: la referente a los colores y texturas, y la referente a las entidades.
	\item En el caso de los botones de selección de entidad, deben modificar la estructura de la figura, por eso lo más sencillo es realizar lo visto en la anterior iteración, crear un mixin por entidad. Así, cada vez que pulsemos un botón distinto, solo será necesario acceder a la entidad (gracias al "id") y modificar su atributo mixin.
	\item El caso para colores y texturas es más sencillo. No necesitamos ningún mixin, solo accedemos a su atributo color o source, y lo modificamos.
	\item Por último, resta crear una nueva entidad cuando saquemos del podio la editada. Se podría repetir el primer paso, crear una entidad aleatorio y vuelta a lo mismo, pero si queremos crear dos entidades iguales, ¿tenemos que editarla dos veces?. Es aquí cuando surge la función "cloneEntity", la cual una vez hemos retirado la entidad del podio, realiza una copia idéntica a la ya creada. La entidad separada, pasará entonces a ser una hija de la escena, y no del podio, y delegará su "id" al clon (el cual será la nueva hija del podio), generando un bucle infinito que permite extraer todas las figuras necesarias.
\end{enumerate}

De todos estos pasos, podemos generar una nueva funcionalidad de los botones de color y textura. Como el color y la textura se corresponden con distintos atributos de una entidad, podemos combinarlos. Esto es, si pulsamos sobre una textura y luego un color, cambiará la tonalidad de esa textura ofreciendo más combinaciones de estilo. 

Al igual que podemos colorear las figuras, quizás necesitemos eliminar su color. La mejor idea es usar el color blanco debido a que si estableces una textura, no vas a querer pulsar el blanco encima de ella y que no surtiría efecto. Esto hace que el color blanco del panel se convierte en el botón de reinicio de estilo.

Podemos observar un ejemplo de estas funcionalidades (podio con entidad variable y textura combinada con color) en la Figura \ref{fig:paleta23}.

\begin{figure}
	\centering
	\includegraphics[width=15cm, keepaspectratio]{IMAGENES/paleta23}
	\caption{Panel con botones para colores y texturas}
	\label{fig:paleta23}
\end{figure}

Lo último que quedaba para terminar esta iteración, era el control de tamaño. Para esta modificación, la idea inicial fue implementarlo como el color y texturas, a través de botones, pero además de no ser intuitivo, solo permitiría editar el tamaño en las mismas cantidades que el número de botones establecidos. La idea sucesora, y la finalmente implementada, fue una barra deslizable.

A-Frame no proporciona ninguna entidad que represente una barra deslizante, pero gracias a GitHub podemos encontrar muchos scripts que definen varios componentes que nos interese importar directamente a nuestro proyecto, entre ellos la barra deslizable. En este caso, la biblioteca aportada por el usuario \textbf{rdub80}\footnote{https://github.com/rdub80/aframe-gui}, proporcionaba diversos elementos como barras de progreso, etiquetas y la empleada, barra deslizante.

Este elemento se divide en: la barra y un punto de referencia. La movilidad del elemento ya esta creado, pero falta enlazarlo con nuestra entidad del podio. La referencia para determinar el tamaño se encuentra en la posición del punto de referencia. Mediante JavaScript, obtenemos la situación del punto de referencia (que por defecto se encuentra en el centro de la barra, para permitirnos elegir aumentar o disminuir) en la escena, y siguiendo un sencillo algoritmo modificamos el atributo escala de la entidad. Quedaría entonces una escena como la que podemos ver en la Figura \ref{fig:slider}, en la que hemos decidido hacer crecer al máximo un cubo.

\begin{figure}
	\centering
	\includegraphics[width=15cm, keepaspectratio]{IMAGENES/slider}
	\caption{Escena con panel de edición y barra deslizable}
	\label{fig:slider}
\end{figure}

\subsection{Resultado}

Hemos conseguido así, una gran funcionalidad para nuestro entorno de realidad virtual. No se encontraron dificultades añadiendo la barra deslizable ni mejorando el panel, pero lo más costoso (y más importante), fue realizar la clonación de entidades y la edición de estas. Como siempre, el código HTML\footnote{https://github.com/JavierBravoDonaire/A-frame/blob/master/Sprint\%203/improve.html} y JavaScript\footnote{https://github.com/JavierBravoDonaire/A-frame/blob/master/Sprint\%203/improve.js}, están almacenados en el repositorio referente al proyecto en GitHub, y se encuentra disponible el enlace para probar la versión funcional de esta iteración \footnote{https://javierbravodonaire.github.io/A-frame/Sprint\%203/improve.html}.

\section{Sprint 4} 
\label{sec:sprint4}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RESULTADOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Resultado Final}
\label{chap:resultado}

En este capítulo se incluyen los resultados de tu trabajo fin de grado.

Si es una herramienta de análisis lo que has realizado, aquí puedes poner ejemplos de haberla utilizado para que se vea su utilidad.

\section{Manual de Usuario}
\label{sec:manual}

\section{Arquitectura resultante}
\label{sec:arquitectura}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONCLUSIONES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Conclusiones}
\label{chap:conclusiones}


\section{Consecución de objetivos}
\label{sec:consecucion-objetivos}

En este apartado, echaremos una vista atrás al capítulo de objetivos (Capítulo )\ref{sec:intro}) y se debatirá si se logro la consecución y los problemas que surgieron.

En general, todos los objetivos propuestos se han solventado con éxito con el paso de las iteraciones. Se ha logrado desarrollar un entorno en realidad virtual didáctico y de fácil uso en el navegador. Trata de una escena en tres dimensiones, en la cual, encontramos un espacio infinito con un suelo a los pies del usuario y, de frente, un panel y un podio para poder empezar con la tarea deseada. 

Se aportan dos modos de creación de figuras, mesa de entidades y panel con botones. Cada entidad tiene su propia paleta de edición de color y textura, por si se cambia de opinión sobre su estilo una vez creada. Añadiendo, la capacidad de elección de tamaño a través de una barra deslizable.

Como añadido, se realizaron las modificaciones pertinentes para permitir al usuario cambiar entre la versión de escritorio y la versión con gafas de realidad virtual, agregando botones para hacer más intuitivo su acceso mediante los mandos u acciones como engrandar una entidad con los dos mandos.

Se consiguió una correcta movilidad del usuario por la escena, permitiéndole volar y girar en cualquier dirección, además de agregar su versión con gafas, en la que el sentido de movimiento viene dado por la dirección de nuestra vista.

El modo edición de la escena que nos permite observar los ejes de las entidades, así como su esqueleto, se implementó con éxito permitiendo al usuario obtener una visión más esquemática de la escena.

Por último, se logró correctamente alojar todos los ejemplos funcionales y la versión final del proyecto en GitHub para el uso de cualquier usuario, como se ha podido observar en los enlaces que se adjuntaban a lo largo del capítulo \ref{chap:disenio}. 

\section{Aplicación de lo aprendido}
\label{sec:aplicacion}

Durante mi grado he recibido muchas lecciones en diferentes ramas de las tecnologías, entre ellas el software, la cual es la base de este proyecto. Algunas de las asignaturas que me han hecho más llevadero el avance son las siguientes:

\begin{enumerate}
  \item Asignaturas como \textit{Servicios y Aplicaciones Telemáticas} me han permitido obtener una base en HTML, además de conocer la estructura del DOM y el diagnóstico de errores en la consola del navegador.
  \item Gracias a la asignatura \textit{Desarrollo de Aplicaciones Telemáticas}, pude cumplimentar mi aprendizaje en JavaScript ya que coincidió el lapso de tiempo de la asignatura con el trabajo.
  \item \textit{Ingeniería en Sistemas de Información} fue la encargada de enseñarme todos los conocimientos necesarios para el control de versiones y el uso de GitHub.
  \item \textit{Sistemas Operativos} además de aportarme los conocimientos sobre un lenguaje de programación, me proporcionó unas nociones básicas del manejo de la consola de Linux, con la cual, pude manejar mis archivos, crear un servidor donde probar mi trabajo e instalar diversas aplicaciones como Atom.
  \item Todas las materias que consistían en fundamentos de programación han sido las responsables de aportarme los cimientos de distintos lenguajes de programación, así como la algoritmia y pensamiento que hay detrás de ello.
\end{enumerate}


\section{Lecciones aprendidas}
\label{sec:lecciones_aprendidas}

A continuación, se encuentran todos los conocimientos adquiridos gracias a este Trabajo de Fin de Grado.

\begin{enumerate}
  \item Aprendizaje del framework para creación de experiencias A-Frame. En esto se incluye, creación de escenas, desarrollo de componentes, agregación y edición de entidades, control de la cámara e iluminación. Para esto, se profundizó en la estructura ECS y en la estructura de elementos HTML, etiquetas y atributos.
  \item Manejo de eventos y modificación de elementos a tiempo real mediante el uso de JavaScript.
  \item Competencia en la resolución de errores, como la propagación de eventos padre-hijo vista en el apartado \ref{sec:sprint2}.
  \item Capacidad de crear un servidor de forma local donde poder depurar y probar el trabajo realizado.
  \item Habilidad para desenvolverme con el uso de las gafas de realidad virtual, así como, la adaptación del trabajo a estas y la conexión con el ordenador para permitir una depuración más veloz.
  \item Importación de modelos 3D a la escena y correcta inyección, permitiendo usar las animaciones vinculadas a estos.
  \item Manejo de la plataforma de control de versiones GitHub.
  \item Uso de LaTeX para la edición de textos científico-técnicos.
\end{enumerate}


\section{Trabajos futuros}
\label{sec:trabajos_futuros}

Todos los proyectos basados en ingeniería de software siguen una máxima: un trabajo nunca se termina, siempre podemos mejorarlo y añadir funcionalidades. Por lo que a continuación se incluyen algunas ideas que serían factibles incluir en un futuro:

\begin{itemize}
	\item Añadir una función para cambiar entre el láser que se usa actualmente por unas manos con la misión de poder interactuar con las entidades y los botones con ellas.
	\item Incluir dinámicas en las entidades para poder apilarlas, tirarlas y dotarlas de movimiento en general.
	\item Opción de guardar una entidad específica con su color, tamaño y posición al dejarla sobre un podio o la propia mesa, con el objetivo de usarla más tarde o incluso clonarla.
	\item Opción de moldear las entidades a nuestro gusto, por ejemplo quitándoles los vértices o creando agujeros en ellas.
	\item Agregar acciones mediante movimientos de las manos.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APÉNDICE(S) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\appendix
%\chapter{Manual de usuario}
%\label{app:manual}
%
%Esto es un apéndice.
%Si has creado una aplicación, siempre viene bien tener un manual de usuario.
%Pues ponlo aquí.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BIBLIOGRAFIA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage

% Las siguientes dos instrucciones es todo lo que necesitas
% para incluir las citas en la memoria
\bibliographystyle{abbrv}
\bibliography{memoria}  % memoria.bib es el nombre del fichero que contiene
% las referencias bibliográficas. Abre ese fichero y mira el formato que tiene,
% que se conoce como BibTeX. Hay muchos sitios que exportan referencias en
% formato BibTeX. Prueba a buscar en http://scholar.google.com por referencias
% y verás que lo puedes hacer de manera sencilla.
% Más información: 
% http://texblog.org/2014/04/22/using-google-scholar-to-download-bibtex-citations/
\end{document}
